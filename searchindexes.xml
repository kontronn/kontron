<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<search>
  
  <entry>
    <title>Linux系统内核概述</title>
    <url>/post/linux/linux-kernel-overview.html</url>
    <categories><category>Linux</category>
    </categories>
    <tags>
      <tag>Kernel</tag>
    </tags>
    <content type="html"><![CDATA[Linux 内核是一种开源的类 Unix 操作系统宏内核。
Linux 内核是 Linux 操作系统的主要组件，也是计算机硬件与其进程之间的核心接口。它负责两者之间的通信，还要尽可能高效地管理资源。之所以称为内核，是因为它在操作系统中就像果实硬壳中的种子一样，并且控制着硬件的所有主要功能。内核的用途主要有以下 4 项工作：
  内存管理：追踪记录有多少内存存储了什么以及存储在哪里
  进程管理：确定哪些进程可以使用中央处理器、何时使用以及持续多长时间
  设备驱动程序：充当硬件与进程之间的调解程序/解释程序
  系统调用和安全防护：从流程接受服务请求
  在正确实施的情况下，内核对于用户是不可见的，它在自己的小世界(称为内核空间)中工作，并从中分配内存和跟踪所有内容的存储位置。用户所看到的内容则被称为用户空间。这些应用通过系统调用接口(SCI)与内核进行交互。
内核简介 单内核体系设计、但充分借鉴了微内核设计体系的优点，为内核引入模块化机制。
Linux 内核的重要组成部分，主要有以下几部分：
kernel内核核心，一般为 bzImage通常在 /boot 目录下，名称为 vmlinuz-VERSION-RELEASE kernel object内核对象，一般放置于 /lib/modules/VERSION-RELEASE/[ ] ==&gt; N ==&gt; 不编译进内核[M] ==&gt; M ==&gt; 编译为模块文件[*] ==&gt; Y ==&gt; 编译进内核 辅助文件(ramdisk)initrdinitramfs 内核模块 uname 命令 使用格式 uname [OPTION]&hellip;
参数解释  -n 显示节点名称 -r 显示VERSION-RELEASE -s 内核名称 -v 内核版本 -n 节点名 -m 硬件名称 -i 硬件平台 -p 处理器类型 -o 操作系统  # uname -m i686 # uname -r 2.6.32-573.22.1.el6.i686 # uname -a Linux MyServer 2.6.32-573.22.1.el6.i686 ... i686 i386 GNU/Linux lsmod 命令 显示由核心已经装载的内核模块
命令定义 显示的内容来自于: /proc/modules 文件。
使用 lsmod 命令时，常会采用类似 lsmod | grep -i ext4 这样的命令来查询系统是否加载了某些模块。
# cat /proc/modules iptable_filter 2173 0 - Live 0xed9b2000 ip_tables 9567 1 iptable_filter, Live 0xed9a9000 ext3 203718 1 - Live 0xed962000 jbd 65315 1 ext3, Live 0xed904000 xenfs 4360 1 - Live 0xed8e6000 ipv6 271097 14 - Live 0xed88e000 xen_netfront 15871 0 - Live 0xed7d9000 ext4 339812 2 - Live 0xed764000 jbd2 75927 1 ext4, Live 0xed6d9000 mbcache 6017 2 ext3,ext4, Live 0xed6b7000 xen_blkfront 19209 5 - Live 0xed69f000 dm_mirror 11969 0 - Live 0xed68d000 dm_region_hash 9644 1 dm_mirror, Live 0xed67e000 dm_log 8322 2 dm_mirror,dm_region_hash, Live 0xed672000 dm_mod 84711 11 dm_mirror,dm_log, Live 0xed64e000 # lsmod | grep ext4 ext4 339812 2 jbd2 75927 1 ext4 mbcache 6017 2 ext3,ext4 字段含义  第 1 列：表示模块的名称 第 2 列：表示模块的大小 第 3 列：表示依赖模块的个数 第 4 列：表示依赖模块的内容  # lsmod Module Size Used by iptable_filter 2173 0 ip_tables 9567 1 iptable_filter ext3 203718 1 jbd 65315 1 ext3 xenfs 4360 1 ipv6 271097 14 xen_netfront 15871 0 ext4 339812 2 jbd2 75927 1 ext4 mbcache 6017 2 ext3,ext4 xen_blkfront 19209 5 dm_mirror 11969 0 dm_region_hash 9644 1 dm_mirror dm_log 8322 2 dm_mirror,dm_region_hash dm_mod 84711 11 dm_mirror,dm_log modinfo 命令 显示模块的详细描述信息
命令定义 modinfo 列出 Linux 内核中命令行指定的模块的信息。
modinfo 能够查询系统中未安装的模块信息。
若模块名不是一个文件名，则会在 /lib/modules/version 目录中搜索，就像 modprobe 一样。
modinfo 默认情况下，为了便于阅读，以下面的格式列出模块的每个属性：fieldname : value。
语法 modinfo [选项] [ modulename|filename&hellip; ]
选项  -n 只显示模块文件路径 -p 显示模块参数 -a author -d description -l license -0 使用’\0’字符分隔 field 值，而不是一个新行，对脚本比较有用  实战演示 # modinfo ext4 filename: /lib/modules/2.6.32-573.22.1.el6.i686/kernel/fs/ext4/ext4.ko license: GPL description: Fourth Extended Filesystem author: Remy Card, Stephen Tweedie, Andrew Morton, Andreas Dilger, Theodore and others srcversion: CB1B990F5A758DFB0FB12F1 depends: mbcache,jbd2 vermagic: 2.6.32-573.22.1.el6.i686 SMP mod_unload modversions 686 # modinfo btrfs filename: /lib/modules/2.6.32-573.22.1.el6.i686/kernel/fs/btrfs/btrfs.ko license: GPL alias: devname:btrfs-control alias: char-major-10-234 srcversion: B412C18B0F5BF7F1B3C941A depends: libcrc32c,zlib_deflate,lzo_compress,lzo_decompress vermagic: 2.6.32-573.22.1.el6.i686 SMP mod_unload modversions 686 modprobe 命令 装载或卸载内核模块
命令定义 配置文件/etc/modprobe.conf/etc/modprobe.d/*.conf
解决依赖modprobe需要一个最新的modules.dep文件，可以用depmod来生成该文件列出了每一个模块需要的其他模块，modprobe使用这个去自动添加或删除模块的依赖
bash # modules.dep为解决依赖的配置文件，modules.dep.bin二进制文件运行 # ls /lib/modules/2.6.32-358.6.1.el6.i686/ build modules.block modules.ieee1394map modules.ofmap modules.symbols.bin weak-updates extra modules.ccwmap modules.inputmap modules.order modules.usbmap kernel modules.dep modules.isapnpmap modules.pcimap source modules.alias modules.dep.bin modules.modesetting modules.seriomap updates modules.alias.bin modules.drm modules.networking modules.symbols vdso 语法 modprobe [ -c ]
modprobe [ -l ] [ -t dirname ] [ wildcard ]
modprobe [ -r ] [ -v ] [ -n ] [ -i ] [ modulename … ]
选项  -v显示程序在干什么，通常在出问题的情况下，modprobe 才显示信息 -C重载，默认配置文件(/etc/modprobe.conf 或 /etc/modprobe.d) -c输出配置文件并退出 -n可以和 -v 选项一起使用，调试非常有用 -i该选项会使得 modprobe 忽略配置文件中的，在命令行上输入的 install 和 remove -q一般 modprobe 删除或插入一个模块时，若没有找到会提示错误。使用该选项，会忽略指定的模块，并不提示任何错误信息。 -r该选项会导致 modprobe 去删除，而不是插入一个模块通常没有没有理由去删除内核模块，除非是一些有 bug 的模块 -f使用该选项是比较危险的和同时使用 –force-vermagic，–force-modversion 一样 -l列出所有模块 -a插入所有命令行中的模块 -t强制 -l 显示 dirname 中的模块 -s错误信息写入 syslog  depmod 命令 内核模块依赖关系文件及系统信息映射文件的生成工具
语法 depmod [-adeisvV][-m &lt;文件&gt;][&ndash;help][模块名称]
参数  -a 分析所有可用的模块 -d 执行排错模式 -e 输出无法参照的符号 -i 不检查符号表的版本 -m&lt;文件&gt; 使用指定的符号表文件 -s 在系统记录中记录错误 -v 执行时显示详细的信息 -V 显示版本信息 &ndash;help 显示帮助  insmod 和 rmmod 命令 装载或卸载内核模块
不解决依赖关系，需要自己手动卸载
insmod命令 向 Linux 内核中插入一个模块
insmod 是一个向内核插入模块的小程序
大多数用户使用 modprobe 因为它比较智能化
insmod [ filename ] [ module options&hellip; ]
rmmod命令 命令解析删除内核中的一模块rmmod 是一个可以从内核中删除模块的小程序，大多数用户使用modprobe -r去删除模块
语法格式rmmod [ modulename ]
参数选项-f除非编译内核时 CONFIG_MODULE_FORCE_UNLOAD 被设置该命令才有效果，否则没效果用该选项可以删除正在被使用的模块，设计为不能删除的模块，或者标记为 unsafe 的模块-wrmmod 拒绝删除正在被使用的模块使用该选项后，指定的模块会被孤立起来，直到不被使用-s将错误信息写入 syslog，而不是标准错误(stderr)
/proc 目录 内核把自己内部状态信息及统计信息，以及可配置参数通过 proc 伪文件系统加以输出。
# ls /proc/ 1 1173 22 29855 35 47 60 973 filesystems loadavg scsi version 10 12 23 3 36 48 600 buddyinfo fs locks self vmallocinfo 1071 13 232 30 37 49 61 bus interrupts mdstat slabinfo vmstat 1082 14 234 31 38 5 62 cgroups iomem meminfo softirqs xen 1085 15 24 31314 39 528 7 cmdline ioports misc stat zoneinfo 11 16 25 317 4 531 739 cpuinfo irq modules swaps 1150 17 252 318 40 543 8 crypto kallsyms mounts sys 1162 18 253 32 41 56 808 devices kcore mtd sysrq-trigger 1163 19 26 320 42 566 830 diskstats keys net sysvipc 1165 1908 27 33 43 567 853 dma key-users pagetypeinfo timer_list 1167 2 28 330 44 57 9 driver kmsg partitions timer_stats 1169 20 29 334 45 59 94 execdomains kpagecount sched_debug tty 1171 21 29853 34 46 6 95 fb kpageflags schedstat uptime sysctl 命令 语法格式 sysctl(选项)(参数)
命令参数  -n 打印值时不打印关键字 -e 忽略未知关键字错误 -N 仅打印名称 -w 当改变 sysctl 设置时使用此项 -p 从配置文件 /etc/sysctl.conf 加载内核参数设置 -a 打印当前所有可用的内核参数变量和值 -A 以表格方式打印当前所有可用的内核参数变量和值  默认配置文件 /etc/sysctl.conf
命令使用方式 (1) 设置某参数sysctl -w parameter=VALUE (2) 通过读取配置文件设置参数sysctl -p [/path/to/conf_file]
参数说明 只读：输出信息
可写：可接受用户指定“新值”来实现对内核某功能或特性的配置/proc/sys
两种修改方式 (1) sysctl 命令用于查看或设定此目录中诸多参数sysctl -w path.to.parameter=VALUEsysctl -w kernel.hostname=mail.escapelife.com
(2) echo 命令通过重定向的方式也可以修改大多数参数的值echo &ldquo;VALUE&rdquo; &gt; /proc/sys/path/to/parameterecho &ldquo; www.escapelife.com  &rdquo; &gt; /proc/sys/kernel/hostname
配置文件中常用的几个参数
net.ipv4.ip_forward /proc/sys/net/ipv4/ip_forward vm.drop_caches /proc/sys/vm/drop_caches kernel.hostname /proc/sys/kernel/hostname 修改配置文件 # cat /etc/sysctl.conf # Kernel sysctl configuration file for Red Hat Linux # Controls IP packet forwarding net.ipv4.ip_forward = 0 # Controls source route verification net.ipv4.conf.default.rp_filter = 1 # Do not accept source routing net.ipv4.conf.default.accept_source_route = 0 # Controls the System Request debugging functionality of the kernel kernel.sysrq = 0 # Controls whether core dumps will append the PID to the core filename. # Useful for debugging multi-threaded applications. kernel.core_uses_pid = 1 # Controls the use of TCP syncookies net.ipv4.tcp_syncookies = 1 # Disable netfilter on bridges. net.bridge.bridge-nf-call-ip6tables = 0 net.bridge.bridge-nf-call-iptables = 0 net.bridge.bridge-nf-call-arptables = 0 # Controls the default maxmimum size of a mesage queue kernel.msgmnb = 65536 # Controls the maximum size of a message, in bytes kernel.msgmax = 65536 # Controls the maximum shared segment size, in bytes kernel.shmmax = 4294967295 # Controls the maximum number of shared memory segments, in pages kernel.shmall = 268435456 # Auto-enabled by xs-tools:install.sh net.ipv4.conf.all.arp_notify = 1 实战演示 # 查看所有可读变量 sysctl -a # 修改对应参数 sysctl -w kernel.sysrq=0 sysctl -w kernel.core_uses_pid=1 sysctl -w net.ipv4.conf.default.accept_redirects=0 # 如果希望屏蔽别人 ping 你的主机，配置文件修改 net.ipv4.icmp_echo_ignore_all = 1 # 编辑完成后，请执行以下命令使变动立即生效 /sbin/sysctl -p /sbin/sysctl -w net.ipv4.route.flush=1 /sys 目录 sysfs 伪文件系统，输出内核识别出的各硬件设备的相关属性信息，也有内核对硬件特性的设定信息。有些参数是可以修改的，用于调整硬件工作特性。
udev  udev 是运行用户空间程序。 udev 通 /sys/ 路径下输出的信息动态为各设备创建所需要设备文件。 udev 是 Linux 内核的设备管理器，它取代了 udevadmin 和 hotplug，负责管理 /dev 中的设备节点。 udev 也处理所有用户空间发生的硬件添加、删除事件，以及某些特定设备所需的固件加载。 udev 为设备创建设备文件时，会读取其事先定义好的规则文件，一般在 /etc/udev/rules.d 及 /usr/lib/udev/rules.d 目录下。  ramdisk 文件的制作 方法一 mkinitrd 命令
为当前正在使用的内核重新制作 ramdisk 文件
mkinitrd /boot/initramfs-$(uname -r).img $(uname -r)
# 移动ramdisk文件到/root目录下 mv /boot/initramfs-2.6.32...img /root # 为当前正在使用的内核重新制作ramdisk文件 mkinitrd /boot/initramfs-$(uname -r).img $(uname -r) 方法二 dracut 命令
为当前正在使用的内核重新制作 ramdisk 文件
dracut /boot/initramfs-$(uname -r).img $(uname -r)
# 移动ramdisk文件到/root目录下 mv /boot/initramfs-2.6.32...img /root # 为当前正在使用的内核重新制作ramdisk文件 dracut /boot/initramfs-$(uname -r).img $(uname -r) 查看 ramdisk # 使用file命令查看ramdisk文件发现是以gz压缩存放的 file /boot/initramfs-2.6.32-504.el6.x86_64.img # 改名称，解压 cd /boot/ mv initramfs-2.6.32-504.el6.x86_64.img initramfs-2.6.32-504.el6.x86_64.img.gz gzip -d initramfs-2.6.32-504.el6.x86_64.img.gz # 使用file命令查看发现是以cpio存放的文本文件 file initramfs-2.6.32-504.el6.x86_64.img # 解压这个文本文件 # 之后会在initrd目录下生成相应的文件，一个微型的/root mkdir initrd cd initrd cpio -id &lt; ../initramfs-2.6.32-504.el6.x86_64.img # 这个时候就可以查看init脚本文件了 cat init # 在sbin文件中存放着相关的命令 ls sbin 编译内核 前提准备 (1) 准备好开发环境
包组(CentOS 6)
Server Platform Development
Development Tools
(2) 获取目标主机上硬件设备的相关信息
CPUcat /proc/cpuinfox86info -alscpu
PCI 设备lspci-v-vvlsusb-v-vvlsblk
了解全部硬件设备信息hal-device
(3) 获取到目标主机系统功能的相关信息
(4) 获取内核源代码包
 www.kernel.org  
简易安装内核 简易安装 获取当前系统的安装文件作为模块安装较为方便
修改相应的参数即可
只适用于当前特定的内核版本
当前系统的安装文件在 config-2.6.32-504.el6.x86_64
简单依据模板文件的制作内核 # 下载对应的Linux内核版本进行解压缩 # 会在/usr/src目录下创建debug、kernels和linux-3.10.67目录 tar xf linux-3.10.67.tar.xz -C /usr/src # 为了方便多内核共存，使用连接指向 # 会在当前目录下创建一个链接文件 linux -&gt; linux-3.10.67 cd /usr/src ln -sv linux-3.10.67 linux # 创建模板 cd linux # 查看链接指向的文件内容 ls # 拷贝系统自带的模板文件 cp /boot/config-$(uname -r) .config # 打开图形界面配置内核选项，选择添加、删除内核模块 # 添加的默认选项来自.config配置文件 make menuconfig # 使用screen来不中断安装 screen # 采用几个线程进行编译 make -j n # 安装内核 make modules_install # make install中将会安装内容 # 安装bzImage为/boot/vmlinuz-VERSION-RELEASE # 生成initramfs文件 # 编辑grub的配置文件 make install # 重启系统，并测试使用新内核，不是默认启动内核 init 6 详解编译内核 (1) 配置内核选项 支持“更新”模式进行配置  (a) make config：基于命令行以遍历的方式去配置内核中可配置的每个选项 (b) make menuconfig：基于 curses 的文本窗口界面 (c) make gconfig：基于 GTK 开发环境的窗口界面 (d) make xconfig：基于 Qt 开发环境的窗口界面  支持“全新配置”模式进行配置  (a) make defconfig：基于内核为目标平台提供的“默认”配置进行配置 (b) make allnoconfig: 所有选项均回答为”no“  (2) 编译 - make [-j #] 如何只编译内核中的一部分功能
# (a)只编译某子目录中的相关代码 cd /usr/src/linux make dir/ # (b)只编译一个特定的模块 cd /usr/src/linux make dir/file.ko # 例如：只为e1000编译驱动 make drivers/net/ethernet/intel/e1000/e1000.ko 如何交叉编译内核
# 编译的目标平台与当前平台不相同； make ARCH=arch_name # 要获取特定目标平台的使用帮助 make ARCH=arch_name help 如何在已经执行过编译操作的内核源码树做重新编译
# 事先清理操作 # 清理大多数编译生成的文件，但会保留config文件等 make clean # 清理所有编译生成的文件、config及某些备份文件 make mrproper # mrproper、patches以及编辑器备份文件 make distclean ]]></content>
  </entry>
  
  <entry>
    <title>如何在 Linux 使用 pv 命令监控数据传输速度与进度</title>
    <url>/post/linux/using-pv-cmd-to-monitor-data-transfer-speed-and-progress.html</url>
    <categories><category>Linux</category>
    </categories>
    <tags>
      <tag>pv</tag>
    </tags>
    <content type="html"><![CDATA[pv 命令是一个在 Linux/Unix 系统的实用工具，用于监控数据的流动。pv 命令可以用于计算数据传输的速度，显示进度条以及估算剩余时间等。
pv命令可以通过管道监控数据流的进度，但是无法直接监控mv命令的进度。这是因为mv命令实际上是将文件从一个位置移动到另一个位置，而不是在管道中传输数据。
默认情况下，pv 命令只会显示一个进度条，以及传输速度和估算的剩余时间等信息。除了默认的进度条外，pv 命令还支持许多选项。
在本教程中，我们将会说明如何在 Linux 使用 pv 命令监控数据的传输速度并估算剩余时间等信息。
pv 命令 pv 命令的使用非常简单，只需在终端输入 pv 命令，后面是需要监视的文件或数据流即可。
pv file.txt &gt; /dev/null pv 命令选项 这些选项可以用于更好地控制 pv 命令的输出。下面是一些常用的选项：
 -f，&ndash;force：  强制 pv 命令执行，即使标准错误不是终端也输出。
 -n，&ndash;numeric：  显示数字的百分比和速度而不是进度条。
 -q，&ndash;quiet：  不输出错误和警告信息。
 -s，&ndash;size SIZE：  指定输入流的大小。
 -t，&ndash;timer：  显示时间估计。
 -h，&ndash;help：  显示 pv 命令的帮助信息。
 -V，&ndash;version：  显示 pv 命令的版本信息。
下面是一些使用pv命令的示例：
监控文件传输 在这个示例中，pv 命令将 file.txt 文件的内容输出到 /dev/null 空设备中，这是一个类似于垃圾桶的设备，只可写入但无法读取的设备。
可以将其用于丢弃不需要的输出。pv 命令会计算 file.txt 文件的大小并显示一个进度条，以及估算剩余时间和传输速度等信息。
pv file.txt &gt; /dev/null 监控标准输入流向标准输出的数据 在这个示例中，pv 命令将 file.txt 文件的内容通过管道传递给 gzip 命令进行压缩，然后将压缩后的数据写入到 file.txt.gz文件。
pv 命令会监控管道中的数据流，并显示一个进度条，以及估算剩余时间和传输速度等信息。
cat file.txt | pv | gzip &gt; file.txt.gz 评估数据传输时间 在这个示例中，pv 命令将 iso 镜像文件的内容通过管道传递给 dd 命令进行写入，pv命令会计算 iso 文件的大小并显示一个进度条，以及估算剩余时间和传输速度等信息。
pv -pteb file.iso | dd of=/dev/sdb 使用场景 以上示例只是 pv 命令的基本用法，但实际上，pv 命令可以在许多场景中发挥重要的作用。例如，在备份文件或复制大量文件时，pv 命令可以帮助用户跟踪数据的传输速度和进度，以及估算剩余时间。
对于网络传输或云存储等场景中，pv 命令可以帮助用户监视数据流，确保传输的可靠性和效率。
此外，在编写脚本或命令行工具时，pv 命令也可以用于监视数据流并提供更好的用户体验。
除了以上介绍的选项和示例外，pv 命令还具有许多其他功能。例如，pv 命令可以与其他命令和工具结合使用，如tar、rsync、scp等，实现更复杂的数据传输和备份操作。此外，pv 命令还支持在终端显示颜色，以便用户更容易地识别不同类型的信息。
限制 需要注意的是，pv 命令虽然非常实用，但也有一些局限性。首先，pv 命令只能监控单个数据流，而不能同时监控多个数据流。其次，pv 命令无法解密加密的数据流，因此无法直接监视加密的数据流。
最后，pv 命令会消耗一定的 CPU 资源和内存，因此在处理大文件或大量数据时，可能会对系统性能产生一定的影响。
总的来说，pv 命令是一个非常实用的 Linux/Unix 工具，可以帮助用户监控数据流，计算传输速度和估算剩余时间等信息。
通过结合不同的选项和示例，用户可以充分利用 pv 命令的功能，以更好地管理和监视数据传输和备份操作。
如果您有任何问题或反馈，请随时发表评论。点击下方阅读原文获取更好排版格式与文章参考引用。
]]></content>
  </entry>
  
  <entry>
    <title>关于extern C的的详细剖析</title>
    <url>/post/programming/extern-c-detailed-analysis.html</url>
    <categories><category>Programming</category>
    </categories>
    <tags>
      <tag>C</tag>
      <tag>extern</tag>
    </tags>
    <content type="html"><![CDATA[在你工作过的系统里，不知能否看到类似下面的代码。
这好像没有什么问题，你应该还会想 “嗯，是啊，我们的代码都是这样写的，从来没有因此碰到过什么麻烦啊～”。
你说的没错，如果你的头文件从来没有被任何C++程序引用过的话。
这与C++有什么关系呢? 看看__cplusplus（注意前面是两个下划线）的名字你就应该知道它与C++有很大关系。__cplusplus是一个C++规范规定的预定义宏。你可以信任的是：所有的现代C++编译器都预先定义了它；而所有C语言编译器则不会。另外，按照规范__cplusplus的值应该等于1 9 9 7 1 1 L ，然而不是所有的编译器都照此实现，比如g++编译器就将它的值定义为1。
所以，如果上述代码被C语言程序引用的话，它的内容就等价于下列代码。
在这种情况下，既然extern &ldquo;C&rdquo; { }经过预处理之后根本就不存在，那么它和#include指令之间的关系问题自然也就是无中生有。
extern &ldquo;C&quot;的前世今生 在C++编译器里，有一位暗黑破坏神，专门从事一份称作“名字粉碎”(name mangling)的工作。当把一个C++的源文件投入编译的时候，它就开始工作，把每一个它在源文件里看到的外部可见的名字粉碎的面目全非，然后存储到二进制目标文件的符号表里。
之所以在C++的世界里存在这样一个怪物，是因为C++允许对一个名字给予不同的定义，只要在语义上没有二义性就好。比如，你可以让两个函数是同名的，只要它们的参数列表不同即可，这就是函数重载(function overloading)；甚至，你可以让两个函数的原型声明是完全相同的，只要它们所处的名字空间(namespace)不一样即可。事实上，当处于不同的名字空间时，所有的名字都是可以重复的，无论是函数名，变量名，还是类型名。
另外，C++程序的构造方式仍然继承了C语言的传统：编译器把每一个通过命令行指定的源代码文件看做一个独立的编译单元，生成目标文件；然后，链接器通过查找这些目标文件的符号表将它们链接在一起生成可执行程序。
编译和链接是两个阶段的事情；事实上，编译器和链接器是两个完全独立的工具。编译器可以通过语义分析知道那些同名的符号之间的差别；而链接器却只能通过目标文件符号表中保存的名字来识别对象。
所以，编译器进行名字粉碎的目的是为了让链接器在工作的时候不陷入困惑，将所有名字重新编码，生成全局唯一，不重复的新名字，让链接器能够准确识别每个名字所对应的对象。
但 C语言却是一门单一名字空间的语言，也不允许函数重载，也就是说，在一个编译和链接的范围之内，C语言不允许存在同名对象。比如，在一个编译单元内部，不允许存在同名的函数，无论这个函数是否用static修饰；在一个可执行程序对应的所有目标文件里，不允许存在同名对象，无论它代表一个全局变量，还是一个函数。所以，C语言编译器不需要对任何名字进行复杂的处理（或者仅仅对名字进行简单一致的修饰（decoration），比如在名字前面统一的加上单下划线_）。
C++的缔造者Bjarne Stroustrup在最初就把——能够兼容C，能够复用大量已经存在的C库——列为C++语言的重要目标。但两种语言的编译器对待名字的处理方式是不一致的，这就给链接过程带来了麻烦。
例如，现有一个名为my_handle.h的头文件，内容如下：
然后使用C语言编译器编译my_handle.c，生成目标文件my_handle.o。
由于C语言编译器不对名字进行粉碎，所以在my_handle.o的符号表里，这三个函数的名字和源代码文件中的声明是一致的。
随后，我们想让一个C++程序调用这些函数，所以，它也包含了头文件my_handle.h。
假设这个C++源代码文件的名字叫my_handle_client.cpp，其内容如下：
其中，粗体的部分就是那三个函数的名字被粉碎后的样子。
然后，为了让程序可以工作，你必须将my_handle.o和my_handle_client.o放在一起链接。由于在两个目标文件对于同一对象的命名不一样，链接器将报告相关的“符号未定义”错误。
为了解决这一问题，C++引入了链接规范(linkage specification)的概念，表示法为extern&quot;language string&rdquo;，C++编译器普遍支持的&quot;language string&quot;有&quot;C&quot;和&quot;C++&quot;，分别对应C语言和C++语言。
链接规范的作用是告诉C++编译：对于所有使用了链接规范进行修饰的声明或定义，应该按照指定语言的方式来处理，比如名字，调用习惯（calling convention）等等。
链接规范的用法有两种：  单个声明的链接规范，比如：  extern &#34;C&#34; void foo(); 一组声明的链接规范，比如：  extern &#34;C&#34; { void foo(); int bar(); } 对我们之前的例子而言，如果我们把头文件my_handle.h的内容改成：
然后使用C++编译器重新编译my_handle_client.cpp，所生成目标文件my_handle_client.o中的符号表就变为：
从中我们可以看出，此时，用extern &ldquo;C&rdquo; 修饰了的声明，其生成的符号和C语言编译器生成的符号保持了一致。这样，当你再次把my_handle.o和my_handle_client.o放在一起链接的时候，就不会再有之前的“符号未定义”错误了。
但此时，如果你重新编译my_handle.c，C语言编译器将会报告“语法错误”，因为extern&quot;C&quot;是C++的语法，C语言编译器不认识它。此时，可以按照我们之前已经讨论的，使用宏__cplusplus来识别C和C++编译器。修改后的my_handle.h的代码如下：
小心门后的未知世界 在我们清楚了 extern &ldquo;C&rdquo; 的来历和用途之后，回到我们本来的话题上，为什么不能把#include 指令放置在 extern &ldquo;C&rdquo; { &hellip; } 里面？
我们先来看一个例子，现有a.h，b.h，c.h以及foo.cpp，其中foo.cpp包含c.h，c.h包含b.h，b.h包含a.h，如下：
现使用C++编译器的预处理选项来编译foo.cpp，得到下面的结果：
正如你看到的，当你把#include指令放置在extern &ldquo;C&rdquo; { }里的时候，则会造成extern &ldquo;C&rdquo; { } 的嵌套。这种嵌套是被C++规范允许的。当嵌套发生时，以最内层的嵌套为准。比如在下面代码中，函数foo会使用C++的链接规范，而函数bar则会使用C的链接规范。
如果能够保证一个C语言头文件直接或间接依赖的所有头文件也都是C语言的，那么按照C++语言规范，这种嵌套应该不会有什么问题。
但具体到某些编译器的实现，比如MSVC2005，却可能由于 extern &ldquo;C&rdquo; { } 的嵌套过深而报告错误。
不要因此而责备微软，因为就这个问题而言，这种嵌套是毫无意义的。你完全可以通过把#include指令放置在extern &ldquo;C&rdquo; { }的外面来避免嵌套。
拿之前的例子来说，如果我们把各个头文件的 #include 指令都移到extern &ldquo;C&rdquo; { } 之外，然后使用C++编译器的预处理选项来编译foo.cpp，就会得到下面的结果：
这样的结果肯定不会引起编译问题的结果——即便是使用MSVC。
把 #include 指令放置在extern &ldquo;C&rdquo; { }里面的另外一个重大风险是，你可能会无意中改变一个函数声明的链接规范。比如：有两个头文件a.h，b.h，其中b.h包含a.h，如下：
按照a.h作者的本意，函数foo是一个C++自由函数，其链接规范为&quot;C++&quot;。但在b.h中，由于#include &ldquo;a.h&quot;被放到了extern &ldquo;C&rdquo; { }的内部，函数foo的链接规范被不正确地更改了。
由于每一条 #include 指令后面都隐藏这一个未知的世界，除非你刻意去探索，否则你永远都不知道，当你把一条条#include指令放置于extern &ldquo;C&rdquo; { }里面的时候，到底会产生怎样的结果，会带来何种的风险。
或许你会说，“我可以去查看这些被包含的头文件，我可以保证它们不会带来麻烦”。但，何必呢？毕竟，我们完全可以不必为不必要的事情买单，不是吗？
Q &amp; A Q: 难道任何# i n c l u d e指令都不能放在e x t e r n &ldquo;C&quot;里面吗？
A: 正像这个世界的大多数规则一样，总会存在特殊情况。
有时候，你可能利用头文件机制“巧妙”的解决一些问题。比如，#pragma pack的问题。这些头文件和常规的头文件作用是不一样的，它们里面不会放置C的函数声明或者变量定义，链接规范不会对它们的内容产生影响。这种情况下，你可以不必遵守这些规则。
更加一般的原则是，在你明白了这所有的原理之后，只要你明白自己在干什么，那就去做吧。
Q: 你只说了不应该放入e x t e r n &ldquo;C&quot;的，但什么可以放入呢？
A: 链接规范仅仅用于修饰函数和变量，以及函数类型。所以，严格的讲，你只应该把这三种对象放置于extern &ldquo;C&quot;的内部。
但，你把C语言的其它元素，比如非函数类型定义（结构体，枚举等）放入extern &ldquo;C&quot;内部，也不会带来任何影响。更不用说宏定义预处理指令了。
所以，如果你更加看重良好组织和管理的习惯，你应该只在必须使用extern &ldquo;C&quot;声明的地方使用它。即使你比较懒惰，绝大多数情况下，把一个头件自身的所有定义和声明都放置在extern&quot;C&quot;里面也不会有太大的问题。
Q: 如果一个带有函数/变量声明的C头文件里没有e x t e r n &ldquo;C&quot;声明怎么办？
A: 如果你可以判断，这个头文件永远不可能让C++代码来使用，那么就不要管它。
但现实是，大多数情况下，你无法准确的推测未来。你在现在就加上这个extern &ldquo;C&rdquo;，这花不了你多少成本，但如果你现在没有加，等到将来这个头文件无意中被别人的C++程序包含的时候，别人很可能需要更高的成本来定位错误和修复问题。
Q: 如果我的C+ +程序想包含一个C头文件a . h，它的内容包含了C的函数/变量声明，但它们却没有使用e x t e r n &ldquo;C&quot;链接规范，该怎么办？
A: 在a.h里面加上它。
某些人可能会建议你，如果a.h没有extern &ldquo;C&rdquo;，而b.cpp包含了a.h，可以在b.cpp里加上 ：
extern &#34;C&#34; { #include &#34;a.h&#34;} 这是一个邪恶的方案，原因在之前我们已经阐述。但值得探讨的是，这种方案这背后却可能隐含着一个假设，即我们不能修改a.h。不能修改的原因可能来自两个方面：
  头文件代码属于其它团队或者第三方公司，你没有修改代码的权限；
  虽然你拥有修改代码的权限，但由于这个头文件属于遗留系统，冒然修改可能会带来不可预知的问题。
  对 于第一种情况，不要试图自己进行workaround，因为这会给你带来不必要的麻烦。正确的解决方案是，把它当作一个bug，发送缺陷报告给相应的团队 或第三方公司。
如果是自己公司的团队或你已经付费的第三方公司，他们有义务为你进行这样的修改。如果他们不明白这件事情的重要性，告诉他们。如果这些头文 件属于一个免费开源软件，自己进行正确的修改，并发布patch给其开发团队。
在 第二种情况下，你需要抛弃掉这种不必要的安全意识。
因为，首先，对于大多数头文件而言，这种修改都不是一种复杂的，高风险的修改，一切都在可控的范围之 内；
其次，如果某个头文件混乱而复杂，虽然对于遗留系统的哲学应该是：“在它还没有带来麻烦之前不要动它”，但现在麻烦已经来了，逃避不如正视，所以上策 是，将其视作一个可以整理到干净合理状态的良好机会。
Q: 我们代码中关于e x t e r n &ldquo;C&quot;的写法如下，这正确吗?
A: 不确定。
按照C++的规范定义，__cplusplus 的值应该被定义为199711L，这是一个非零的值；尽管某些编译器并没有按照规范来实现，但仍然能够保证__cplusplus的值为非零——至少我到目前为止还没有看到哪款编译器将其实现为0。
这种情况下，#if __cplusplus &hellip; #endif完全是冗余的。
但，C++编译器的厂商是如此之多，没有人可以保证某款编译器，或某款编译器的早期版本没有将__cplusplus的值定义为0。
但即便如此，只要能够保证宏__cplusplus只在C++编译器中被预先定义 ，那么，仅仅使用#ifdef __cplusplus ⋯ #endif就足以确保意图的正确性；额外的使用#if __cplusplus &hellip; #endif反而是错误的。
只有在这种情况下：即某个厂商的C语言和C++语言编译器都预先定义了__cplusplus ，但通过其值为0和非零来进行区分，使用#if __cplusplus &hellip; #endif才是正确且必要的。
既然现实世界是如此复杂，你就需要明确自己的目标，然后根据目标定义相应的策略。比如：如果你的目标是让你的代码能够使用几款主流的、正确遵守了规范的编译器进行编译，那么你只需要简单的使用#ifdef __cplusplus &hellip; #endif就足够了。
但如果你的产品是一个雄心勃勃的，试图兼容各种编译器的（包括未知的）跨平台产品， 我们可能不得不使用下述方法来应对各种情况 ，其中__ALIEN_C_LINKAGE__是为了标识那些在C和C++编译中都定义了__cplusplus宏的编译器。
这应该可以工作，但在每个头文件中都写这么一大串，不仅有碍观瞻，还会造成一旦策略进行修改，就会到处修改的状况。违反了DRY(Don&rsquo;t Repeat Yourself)原则，你总要为之付出额外的代价。解决它的一个简单方案是，定义一个特定的头文件——比如clinkage.h，在其中增加这样的定义：
以下举例中c的函数声明和定义分别在cfun.h 和 cfun.c 中，函数打印字符串 “this is c fun call”，c++函数声明和定义分别在cppfun.h 和 cppfun.cpp中，函数打印字符串 &ldquo;this is cpp fun call&rdquo;, 编译环境vc2010
c++ 调用 c 的方法（关键是要让c的函数按照c的方式编译，而不是c++的方式）
（1） cfun.h如下：
#ifndef _C_FUN_H_ #define _C_FUN_H_  void cfun(); #endif cppfun.cpp 如下：
//#include &#34;cfun.h&#34; 不需要包含cfun.h #include &#34;cppfun.h&#34;#include &lt;iostream&gt;using namespace std; extern &#34;C&#34; void cfun(); //声明为 extern void cfun(); 错误  void cppfun() { cout&lt;&lt;&#34;this is cpp fun call&#34;&lt;&lt;endl; } int main() { cfun(); return 0; } （2）cfun.h同上，cppfun.cpp 如下：
extern &#34;C&#34; { #include &#34;cfun.h&#34;//注意include语句一定要单独占一行;} #include &#34;cppfun.h&#34;#include &lt;iostream&gt;using namespace std; void cppfun() { cout&lt;&lt;&#34;this is cpp fun call&#34;&lt;&lt;endl; } int main() { cfun(); return 0; } （3）cfun.h如下：
#ifndef _C_FUN_H_ #define _C_FUN_H_  #ifdef __cplusplus extern &#34;C&#34; { #endif  void cfun(); #ifdef __cplusplus } #endif  #endif cppfun.cpp如下：
#include &#34;cfun.h&#34;#include &#34;cppfun.h&#34;#include &lt;iostream&gt;using namespace std; void cppfun() { cout&lt;&lt;&#34;this is cpp fun call&#34;&lt;&lt;endl; } int main() { cfun(); return 0; } c调用c++（关键是C++ 提供一个符合 C 调用惯例的函数）
在vs2010上测试时，没有声明什么extern等，只在在cfun.c中包含cppfun.h，然后调用cppfun()也可以编译运行，在gcc下就编译出错，按照c++/c的标准这种做法应该是错误的。以下方法两种编译器都可以运行
cppfun.h如下：
#ifndef _CPP_FUN_H_ #define _CPP_FUN_H_  extern &#34;C&#34; void cppfun(); #endif cfun.c如下：
//#include &#34;cppfun.h&#34; //不要包含头文件，否则编译出错 #include &#34;cfun.h&#34;#include &lt;stdio.h&gt; void cfun() { printf(&#34;this is c fun call\n&#34;); } extern void cppfun(); int main() { #ifdef __cplusplus  cfun(); #endif  cppfun(); return 0; } ]]></content>
  </entry>
  
  <entry>
    <title>风河 Helix 虚拟化平台和 VxWorks 653 提供扩展的安全认证证据支持以加速下一代 A&D 系统的开发</title>
    <url>/post/news/wind-river-helix-virtualization-platform-and-vxWorks-653-deliver-expanded-safety-certification.html</url>
    <categories><category>News</category>
    </categories>
    <tags>
      <tag>Wind River</tag>
      <tag>Helix Virtualization</tag>
      <tag>VxWorks 653</tag>
    </tags>
    <content type="html"><![CDATA[为关键任务智能系统提供软件的全球领导者 Wind River® 今天宣布扩展其行业领先平台的架构支持，以进一步满足高度计算的苛刻需求 - 重型任务关键型应用，特别是那些与航空航天和国防工业相关的应用。
DO-178C DAL A 认证证据现已可用于 Armv8-A 架构的 Wind River Helix™ 虚拟化平台。 最新版本的 VxWorks  ® 653 为 PowerPC 提供更新的 DO-178C DAL A 认证证据。
具有 DO-178C DAL A 证据的 Helix 平台是一个安全认证的多核、多租户平台，支持多个独立的关键级别。 它专为各种关键任务行业用例而设计，例如商业和军事航空电子设备，允许客户运行不安全的软件以及经过最高级别认证的软件，这些软件涉及航空电子设备 (DO-178C)、汽车 (ISO 26262)、工业 ( IEC 61508) 和其他类似标准。 Helix Platform 也符合 ARINC 653 标准，并在最新的硬件平台上提供强大的时间和空间分区，以确保故障遏制以及以最少的测试和集成需求升级应用程序的能力。
VxWorks 653，具有DO-178C DAL A证明，是一个安全可靠的多核、多租户平台，可用于PowerPC架构。 VxWorks 653 也符合 ARINC 653 标准，具有与 Helix 平台相同的稳健性。
“智能边缘的发展为航空航天和国防等行业提出了一系列独特的要求和挑战，包括与认证需求相关的复杂性增加。 随着 Helix 平台和 VxWorks 653 的更新安全认证证据的可用性，我们正在为我们的客户提供更多灵活性和加速创新的机会，以创建下一代安全可靠的多操作系统智能设备，”首席产品 Avijit Sinha 说 军官，风河。
风河技术已在最具挑战性的安全关键型应用中得到验证，使组织能够更轻松、更经济地满足 EN 50128、IEC 61508、ISO 26262、DO-178C 和 ED-12C 的严格安全认证要求。
凭借在 120 多架民用和军用飞机的 880 多个安全项目中得到 400 多家客户验证的技术，风河正在推动航空航天和国防领域向软件定义系统的过渡。
]]></content>
  </entry>
  
  <entry>
    <title>三星电子研发出其首款支持CXL 2.0的CXL DRAM</title>
    <url>/post/news/samsung-develops-first-CXL-DRAM-supporting-CXL-2.0.html</url>
    <categories><category>News</category>
    </categories>
    <tags>
      <tag>Samsung</tag>
      <tag>CXL 2.0</tag>
      <tag>CXL Memory</tag>
    </tags>
    <content type="html"><![CDATA[基于先进CXL 2.0的128GB CXL DRAM将于今年量产，加速下一代存储器解决方案的商用化，三星将继续与全球数据中心、服务器、芯片企业合作，扩大CXL生态系统
三星电子今日宣布，研发出其首款支持Compute Express Link™（CXL™）2.0的128GB DRAM。同时，三星与英特尔密切合作，在英特尔®至强®平台上取得了具有里程碑意义的进展。
继2022年五月，三星电子研发出其首款基于CXL 1.1的CXL DRAM（内存扩展器）后，又继续推出支持CXL 2.0的128GB CXL DRAM，预计将加速下一代存储解决方案的商用化。该解决方案支持PCIe 5.0（x8通道），提供高达每秒35GB的带宽。
三星电子新业务企划副总裁Jangseok Choi表示： 作为CXL联盟的董事会成员，三星电子在CXL技术上一直处于前沿地位，这一突破性的进展强化了我们通过与全球各地的数据中心、企业级服务器和芯片公司合作，进一步扩大CXL生态系统的决心。
英特尔公司技术创新总监Jim Pappas表示： 英特尔很高兴与三星合作，共同投资一个充满活力的CXL生态系统。英特尔将继续与三星携手，促进创新CXL产品在整个行业的发展和采用。
澜起科技总裁Stephen Tai表示： 澜起科技很高兴能够量产第一批支持CXL 2.0的控制器，我们期待与三星继续加强合作，推进CXL技术发展并扩大其生态系统。
CXL 2.0是三星有史以来第一个支持内存池（Pooling）的产品。内存池是一种内存管理技术，它将服务器平台上的多个CXL内存块绑定在一起，形成一个内存池，使多个主机能够根据需要从池中动态分配内存。这项新技术使客户尽可能的降本增效，从而帮助企业将有限的资源重新投资于增强服务器内存中去。
三星电子计划于今年年底之前开始量产这一最新的CXL 2.0 DRAM，并准备推出多种容量的产品，以满足快速变化的下一代计算市场，进一步加速扩大CXL生态系统。
CXL作为下一代，能够为高性能服务器系统中与CPU一起使用的加速器、DRAM和存储设备提高效率。由于它与主内存（main DRAM）共同使用时可扩大带宽和容量，该技术的进步有望在人工智能（AI）和机器学习（ML）等核心技术，对处理高速数据的需求极大增加的下一代计算市场引起轰动。
]]></content>
  </entry>
  
  <entry>
    <title>北南南北</title>
    <url>/about.html</url>
    <categories>
    </categories>
    <tags>
    </tags>
    <content type="html"><![CDATA[北南南北 是众多使用 VxWorks 嵌入式实时操作系统的网友分享经验的平台，为的就是让 VxWorks 的学习和应用变得相对开放一些，在此也欢迎你的加入！
我们的愿景 技术创新是技术持续发展的生命力，紧跟技术的发展趋势，研究最新的技术，保持对新技术的热情和好奇心，让技术为生产和生活服务。
使用反馈  加入 VxWorks Club   或 Google AI TPU     欢迎你的加入
 ]]></content>
  </entry>
  
  <entry>
    <title>友情链接</title>
    <url>/flinks.html</url>
    <categories>
    </categories>
    <tags>
    </tags>
    <content type="html"><![CDATA[如想交换本站友情链接，请在评论区留下你的站点信息，格式参考如下：
name: VxWorks俱乐部 desc: VxWorks实时操作系统 link: https://www.vxworks.net ]]></content>
  </entry>
  
</search>